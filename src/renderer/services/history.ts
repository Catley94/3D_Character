
import { emit } from '../modules/store';

export interface ChatMessage {
    role: 'user' | 'model';
    content: string;
    timestamp: number;
}

export interface MemoryState {
    shortTerm: ChatMessage[];
    longTerm: string;
}

const STORAGE_KEY = 'ai_character_memory';
const SHORT_TERM_LIMIT = 20; // Number of messages to keep in active context
const CONSOLIDATION_THRESHOLD = 30; // When to trigger consolidation

export class HistoryService {
    private state: MemoryState = {
        shortTerm: [],
        longTerm: ''
    };

    constructor() {
        this.load();
    }

    /**
     * Adds a message to the short-term memory.
     * Triggers consolidation if the limit is exceeded.
     */
    public addMessage(role: 'user' | 'model', content: string) {
        const msg: ChatMessage = {
            role,
            content,
            timestamp: Date.now()
        };

        this.state.shortTerm.push(msg);
        this.save();

        this.checkConsolidation();
    }

    /**
     * Returns the context for the AI:
     * - Long-term summary
     * - Recent short-term messages
     */
    public getContext(): { history: ChatMessage[]; summary: string } {
        // Return ALL buffered short-term messages (up to CONSOLIDATION_THRESHOLD)
        // This ensures messages 21-29 are not hidden before consolidation happens
        return {
            history: this.state.shortTerm,
            summary: this.state.longTerm
        };
    }

    /**
     * Clears all memory (useful for debugging or "Forget everything")
     */
    public clear() {
        this.state = { shortTerm: [], longTerm: '' };
        this.save();
        console.log('[History] Memory cleared.');
    }

    /**
     * Appends a new summary to the long-term memory and removes summarized messages.
     * @param summary The summary generated by the AI
     * @param count Number of messages that were summarized
     */
    public applyConsolidation(summary: string, count: number) {
        // Append new summary
        const date = new Date().toLocaleDateString();
        this.state.longTerm += `\n[${date}] ${summary}`;

        // Remove the oldest 'count' messages
        // (We keep the rest as the new "active" short-term)
        if (count > 0 && count <= this.state.shortTerm.length) {
            this.state.shortTerm = this.state.shortTerm.slice(count);
        }

        this.save();
        console.log(`[History] Consolidated ${count} messages into long-term memory.`);
    }

    /**
     * Returns messages that need to be consolidated.
     */
    public getMessagesToConsolidate(): ChatMessage[] {
        // We want to consolidate the oldest messages, leaving the recent ones
        // Example: If we have 30 messages, and we want to keep 20 (SHORT_TERM_LIMIT),
        // we consolidate the first 10.
        const keepCount = SHORT_TERM_LIMIT;
        if (this.state.shortTerm.length <= keepCount) return [];

        const consolidateCount = this.state.shortTerm.length - keepCount;
        return this.state.shortTerm.slice(0, consolidateCount);
    }

    private checkConsolidation() {
        if (this.state.shortTerm.length >= CONSOLIDATION_THRESHOLD) {
            console.log('[History] Threshold reached, requesting consolidation...');
            // Emit event so chat.ts can handle the AI summarization
            emit('consolidation-needed', null);
        }
    }

    private save() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(this.state));
        } catch (e) {
            console.error('[History] Failed to save memory:', e);
        }
    }

    /**
     * Ends the current session by summarizing all pending short-term messages
     * into a single "Session Entry" in long-term memory.
     * Returns true if anything was saved.
     */
    public async endSession(config: any, summarizeFn: (text: string, config: any) => Promise<string>): Promise<boolean> {
        console.log('[History] Ending session...');

        // 1. Check if there's anything to save
        if (this.state.shortTerm.length === 0) {
            console.log('[History] No short-term messages to save.');
            return false;
        }

        // 2. Prepare text
        const messages = this.state.shortTerm;
        const textToSummarize = messages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n');

        // 3. Generate "Session Summary"
        try {
            console.log(`[History] Summarizing session (${messages.length} messages)...`);
            // We ask for a specific "Daily Log" style summary
            // Note: The summarizeFn passed from chat.ts should handle the prompt engineering mostly, 
            // or we do it here? Let's just pass raw text and let the service handle it, 
            // OR we prepend a specific instruction here. 
            // The existing summarize() in services is generic. Let's prepend here.

            const prompt = `This is the end of a session. Create a brief, concise "Session Summary" of what we just discussed, focusing on new facts learned about the user, major events, actions, or decisions. Ignore small talk. Format as a short list of bullet points.\n\n${textToSummarize}`;

            const summary = await summarizeFn(prompt, config);

            if (summary && summary.trim()) {
                // 4. Archive it
                const date = new Date().toLocaleString();
                this.state.longTerm += `\n\n=== [SESSION RECORD: ${date}] ===\n${summary.trim()}\n====================================`;

                // 5. Clear Short Term (Active Context is now "closed")
                // We might keep the very last message? No, "End Session" implies a clean break.
                this.state.shortTerm = [];
                this.save();

                console.log('[History] Session ended and saved.');
                return true;
            }
        } catch (e) {
            console.error('[History] Session summarization failed:', e);
        }

        return false;
    }

    private load() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (raw) {
                const data = JSON.parse(raw);
                // Basic validation
                if (Array.isArray(data.shortTerm)) {
                    this.state = data;
                    console.log(`[History] Loaded: ${this.state.shortTerm.length} msgs, ${this.state.longTerm.length} chars summary`);
                }
            }
        } catch (e) {
            console.error('[History] Failed to load memory:', e);
        }
    }
}

export const historyService = new HistoryService();
