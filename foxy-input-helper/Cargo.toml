# =============================================================================
# Foxy Input Helper - Cargo Configuration
# =============================================================================
# This is the manifest file for our Rust project. It defines:
# - Package metadata (name, version, etc.)
# - Dependencies (external libraries we need)
# - Build settings
#
# Think of it like package.json for Node.js, but for Rust!
# =============================================================================

[package]
# The name of our binary - this will be the executable name
name = "foxy-input-helper"

# Semantic version (major.minor.patch)
version = "0.1.0"

# Rust edition - 2021 is the current stable edition with nice features
edition = "2021"

# Brief description for package registries
description = "A helper binary that reads Linux input devices to provide global cursor position and keyboard shortcuts on Wayland"

# Who made this?
authors = ["Sam"]

# License - same as the main project
license = "MIT"

# =============================================================================
# Dependencies
# =============================================================================
# These are external crates (Rust's term for libraries/packages) from crates.io

[dependencies]
# -----------------------------------------------------------------------------
# evdev - Linux Event Device Library
# -----------------------------------------------------------------------------
# This is the star of the show! It provides a safe Rust interface to the Linux
# input subsystem (/dev/input/event*).
#
# The Linux kernel exposes all input devices (keyboards, mice, touchpads, etc.)
# as "event devices" in /dev/input/. Each device produces a stream of events
# like "key pressed", "mouse moved", etc.
#
# This crate lets us:
# - Enumerate all available input devices
# - Open devices and read their events
# - Understand what type of device each one is (keyboard vs mouse)
#
# Documentation: https://docs.rs/evdev
evdev = "0.12"

# -----------------------------------------------------------------------------
# serde - Serialization/Deserialization Framework
# -----------------------------------------------------------------------------
# Serde is Rust's go-to library for converting data structures to/from various
# formats (JSON, YAML, TOML, etc.).
#
# The "derive" feature lets us use #[derive(Serialize, Deserialize)] on our
# structs, which auto-generates the conversion code at compile time.
#
# We need this to convert our Rust structs into JSON to send to Electron.
serde = { version = "1.0", features = ["derive"] }

# -----------------------------------------------------------------------------
# serde_json - JSON Support for Serde
# -----------------------------------------------------------------------------
# This adds JSON-specific functionality to serde.
# We'll use it to serialize our events to JSON strings.
serde_json = "1.0"

# -----------------------------------------------------------------------------
# nix - Unix/Linux System Calls
# -----------------------------------------------------------------------------
# Provides safe Rust bindings to POSIX/Unix system calls.
#
# We need the "poll" feature for `poll()` - a system call that lets us wait
# for events from multiple file descriptors (input devices) simultaneously.
# Without poll, we'd have to spawn a thread per device or do busy-waiting.
#
# The "fs" feature gives us access to file system operations.
nix = { version = "0.29", features = ["poll", "fs"] }

# -----------------------------------------------------------------------------
# signal-hook - Unix Signal Handling
# -----------------------------------------------------------------------------
# Lets us handle Unix signals gracefully (like SIGTERM, SIGINT).
# When Electron's child process manager sends us a termination signal,
# we want to clean up properly instead of just crashing.
signal-hook = "0.3"

# =============================================================================
# Profile Settings
# =============================================================================
# These control how the compiler builds the project in release mode.

[profile.release]
# Link-Time Optimization - makes the binary smaller and faster
# by optimizing across compilation units
lto = true

# Optimize for size over speed (s = size, z = even smaller)
# Our binary does simple I/O, we don't need maximum speed
opt-level = "s"

# Strip debug symbols from the binary to reduce size
strip = true

# Use a single codegen unit for better optimization
# (slightly slower compile, but smaller/faster binary)
codegen-units = 1
